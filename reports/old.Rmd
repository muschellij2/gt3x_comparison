---
title: "Old Format"
output: html_document
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load the Packages

```{r load}
library(read.gt3x)
library(SummarizedActigraphy)
library(AGread)
library(dplyr)
library(pygt3x)
library(lubridate)

if (packageVersion("read.gt3x") < "0.3.1") {
  stop(
    paste0(
      "Need to install new read.gt3x, ", 
      'remotes::install_github("muschellij2/read.gt3x")')
  )
}

source(here::here("code/helper_functions.R"))
```

We are using the helper functions to read in the CSV files and download some data.

# Download the Data

The data is a one-day sample from the sample data from ActiGraph: https://help.theactigraph.com/entries/21688392-GT3X-ActiSleep-Sample-Data.  The data was downloaded from the following file:

* GT3XPlus-RawData(1-20).zip (169mb) - This Archive contains Raw Data in 1, 2, 3, 4, 5, 10, 15, and 20 day lengths. This was collected using a GT3X+ Device.

but we unzipped the file, extracted the one-day file, and compressed it and uploaded it to Figshare.  We also have the CSV file that was generated by the ActiGraph ActiLife software. 

Here we download the data from Figshare.

```{r}
gt3x_file = dl("24459680")
gt3x_file
csv_file =  dl("24459683", ".csv.gz")
csv_file
```

# Read in the CSV

The ActiGraph CSV output is what we're considering as the "ground truth".  Note, the file format has a 10 line header and then the "data", and note that no time is given, it is assumed that the start date is the first record and then each record is 1 unit in the sampling frequency/sample rate (in this case 30Hz):

```{r}
readLines(csv_file, 15)
```

The `read_acc_csv` function simply reads in the header and the data (after skipping lines) and creates a `time` variable.  We want the column names to be `X`, `Y`, and `Z` so we strip off the `Accelerometer` label. 

```{r}
df = read_acc_csv(csv_file)
hdr = df$header
df = df$data
colnames(df) = sub("Accelerometer ", "", colnames(df))
head(hdr)
head(df)
tail(df)
nrow(df)
```

We see we have `r nrow(df)` records from the truth, which is not going to agree with the data below.  If the data does not agree, but all values are zero, I believe this is as good as we can assume to get.  This assumption is based on the fact we don't have the source code for the ActiLife software, and can only go off of https://github.com/actigraph/NHANES-GT3X-File-Format as a template.

# Read in the GT3X

## What is a GT3X
A `.gt3x` file is simply a zipped folder, but with specific files in there.  In the older NHANES format, we are interested in the `info.txt` and `activity.bin`:

```{r}
unzipped_gt3x = R.utils::gunzip(
  gt3x_file, remove = FALSE, temporary = TRUE, overwrite = TRUE)
tfile = tempfile()
output = unzip(unzipped_gt3x, exdir = tfile)
files = output[basename(output) %in% c("activity.bin", "info.txt")]
files
```
We can calculate the number of samples from https://github.com/actigraph/NHANES-GT3X-File-Format#steps-to-parse-activity-and-light-data-from-a-gt3x-file by
> calculate total number of samples by multiplying the file size (in bytes) of the activity.bin file by 8 (bits per byte) and then dividing by 36 (bits per sample).

```{r nsamples}
fsize = file.size(files[ grepl("activity.bin", files)])
fsize
print({est_sample_size = round((fsize + 4) * 8 / 36)})
```

```{r unlink}
unlink(tfile, recursive = TRUE)
```


## read.gt3x

Here we are going to read in the GT3X file from `read.gt3x`:

```{r}
act_df = read.gt3x(gt3x_file, verbose = TRUE,
                   asDataFrame = TRUE, imputeZeroes = TRUE)
head(act_df)
at = attributes(act_df)
at$light_data = NULL

class(act_df) = "data.frame"
act_df = act_df[, c("time", "X", "Y", "Z")]
```


### Errors in Time

Here we see the last time of the data set is **after** the download date of the data - indicating some errors in the data.  This is referenced in https://github.com/THLfi/read.gt3x/issues/20 and https://github.com/THLfi/read.gt3x/issues/3, which are issues that are in the works of hopefully being fixed.

```{r}
print(at$header$`Sample Rate`)
at$header$`Download Date`
tail(act_df)
last_time = act_df$time[ nrow(act_df)]

bad_time = last_time > at$header$`Download Date`
bad_time = bad_time | (last_time > at$header$`Stop Date`)
bad_time
stopifnot(bad_time)
```

In future releases of `read.gt3x`, this will stop this report to indicates changes need to be made:

```{r}
stopifnot(bad_time)
```

Right now, we will make the time ourselves

```{r}
act_df$time = at$start_time +
  lubridate::as.period(
    (0:(nrow(act_df)-1))/at$sample_rate,
    unit = "secs")

last_time2 = act_df$time[ nrow(act_df)]
last_time2 == at$header$`Download Date`
last_time2 == at$header$`Stop Date`
```

## AGread

Here we are going to read in the GT3X file from `AGread`, but it cannot at the time of running.  This is a check to see if new implementations/versions can read it in:
```{r}
ag = try({
  AGread::read_gt3x(gt3x_file)
}, silent = TRUE)
stopifnot(inherits(ag, "try-error"))
attributes(ag) = NULL; cat(ag)
```

## pygt3x

Here we are going to read in the GT3X file from `pygt3x` (https://github.com/muschellij2/pygt3x).  There are issues with the last values as we see here, which we do not recommend.  The `impute_zeros

```{r, error=TRUE}
py = pygt3x::py_read_gt3x(gt3x_file, verbose = 2)
max_py = max(abs(py$data)) 
py_success = max_py < 6.1
stopifnot(py_success)
py = pygt3x::impute_zeros(py)
head(py)
tail(py)
```



## Comparison

Here we look at the records and see if they match up.  This comparison relies on a "good" reading of the data from `pygt3x` (which should now be fixed for old formats in versions `>= 0.0.8`, other testing needs to be done):

```{r}
if (py_success) {
  d = act_df == py
  stopifnot(all(d))
}
```

## "Fixing" zeros

In many cases there will be zeros for all values of `X`, `Y`, and `Z` axes.  There are some instances/measures you want to do the last observation carried forward, which is what idle sleep mode tends to do in ActiLife.

```{r}
act_df_fixed = SummarizedActigraphy::fix_zeros(act_df)
py_fixed = SummarizedActigraphy::fix_zeros(py)
```


## Full comparison

They agree!

```{r}
stopifnot(all(df[, c("X", "Y", "Z")] == act_df[, c("X", "Y", "Z")]))
stopifnot(all(df[, c("X", "Y", "Z")] == py[, c("X", "Y", "Z")]))
```
